<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: BSD | rcmdnk's blog]]></title>
  <link href="https://rcmdnk.com/blog/tags/bsd/atom.xml" rel="self"/>
  <link href="https://rcmdnk.com/"/>
  <updated>2020-08-11T00:23:45+00:00</updated>
  <id>https://rcmdnk.com/</id>
  <author>
    <name><![CDATA[rcmdnk]]></name>
    <email><![CDATA[rcmdnk@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GNU/BSDでのxargsの振る舞いの違い]]></title>
    <link href="https://rcmdnk.com/blog/2017/06/01/computer-linux-gnu-bsd/"/>
    <updated>2017-06-01T00:00:00+00:00</updated>
    <id>https://rcmdnk.com/blog/2017/06/01/computer-linux-gnu-bsd</id>
    <content type="html"><![CDATA[<div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/6131493480?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=6131493480&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/41iyzcjjHgL._SS200_.jpg" alt="Xargs" /></a>
</div>

<p><code>find</code>コマンドなどと組み合わせてパイプから受け取る入力を
引数としてコマンドを実行する<code>xargs</code>ですが、
GNU版とBSD版の間で違いが結構大きい様です。</p>

<p>ちょっと調べたら色々あるみたいなんですが、
今回ひっかかった特にはまりやすいかな、と思う点についてメモしておきます。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#出力が空の場合に一回実行するかどうか" id="markdown-toc-出力が空の場合に一回実行するかどうか">出力が空の場合に一回実行するかどうか</a></li>
  <li><a href="#no-run-if-empty--r-オプション" id="markdown-toc-no-run-if-empty--r-オプション">–no-run-if-empty (-r) オプション</a></li>
  <li><a href="#オプションを扱うラッパー関数" id="markdown-toc-オプションを扱うラッパー関数">オプションを扱うラッパー関数</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div>
  <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3802317723662375" data-ad-slot="5762198341"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  </div>
</div>

<h2 id="出力が空の場合に一回実行するかどうか">出力が空の場合に一回実行するかどうか</h2>

<p>簡単な例として、<code>echo</code>で出力を作ってそれをそのまま<code>echo</code>で受け流す様な<code>xargs</code>の使い方を考えます。</p>

<pre><code>$ echo aaa| xargs echo "bbb"
bbb aaa
</code></pre>

<p>こんな感じ。パイプの後ろは</p>

<pre><code>$ echo bbb aaa
</code></pre>

<p>に置き換わって実行されています。
これはGNUでもBSDでも同じように実行されます。</p>

<p>次に最初の出力を空にしてみます。</p>

<p>MacなどのBSD系では</p>

<pre><code>$ echo | xargs echo "bbb"
$
</code></pre>

<p>と何も表示されません。</p>

<p>一方GNU版だと</p>

<pre><code>$ echo | xargs echo "aaa"
aaa
$
</code></pre>

<p>と、<code>echo</code>が実行されます。</p>

<p>これは例えばある特定のディレクトリにある特定の名前のファイルを表示したい時、</p>

<pre><code>$ find /path/to/dir/ -maxdepth 1 -mindepth 1 -type f -name "*wanted*" -print0 2&gt;/dev/null|xargs -0 -n1 basename
</code></pre>

<p>こんなコマンドをやるとします。</p>

<p>もし何も見つからない場合、BSD版では何も表示されない状態で正常終了します。</p>

<pre><code>$ find /path/to/dir/ -maxdepth 1 -mindepth 1 -type f -name "*wanted*" -print0 2&gt;/dev/null|xargs -0 -n1 basename
$ echo $?
0
$
</code></pre>

<p>一方GNU版だと</p>

<pre><code>$ find /path/to/dir/ -maxdepth 1 -mindepth 1 -type f -name "*wanted*" -print0 2&gt;/dev/null|xargs -0 -n1 basename
basename: missing operand
Try `basename --help' for more information.
$ echo $?
123
$
</code></pre>

<p>な感じで<code>basename</code>が引数なしで一回実行されてしまうのでエラー終了になります。</p>

<h2 id="no-run-if-empty--r-オプション">–no-run-if-empty (-r) オプション</h2>

<p>スクリプトを使いまわしたい場合にこれだとちょっと面倒ですが、
GNU版には<code>--no-run-if-empty</code>というオプションがあり
これを与えるとBSDの様に何もパイプから受け取らない場合にはコマンドを実行しない様になります。
<code>-r</code>というオプションも同様の動作をします。</p>

<p>一方、BSD版の一部のものだと、この<code>-r</code>を擬似オプション(何も変更しないオプション)として導入し、
BSDでもGNUでも<code>xargs -r</code>とすれば同様の動作をする様に出来る事ができます。</p>

<p>ただ、Macに入ってる<code>xargs</code>などは<code>-r</code>オプションが無いので使うとエラーが出ます。</p>

<p>なのでちゃんと調べて上げる必要があって、</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span></span><span class="k">if</span> <span class="o">[</span> ! -v xargs_opt <span class="o">]</span><span class="p">;</span><span class="k">then</span>
</span><span class="line">  <span class="k">if</span> echo<span class="p">|</span>xargs -r &gt;/dev/null <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="p">;</span><span class="k">then</span>
</span><span class="line">    <span class="nv">xargs_opt</span><span class="o">=</span><span class="s2">&quot;-r&quot;</span>
</span><span class="line">  <span class="k">else</span>
</span><span class="line">    <span class="nv">xargs_opt</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
</span><span class="line">  <span class="k">fi</span>
</span><span class="line"><span class="k">fi</span>
</span><span class="line">find /path/to/dir/ -maxdepth <span class="m">1</span> -mindepth <span class="m">1</span> -type f -name <span class="s2">&quot;*wanted*&quot;</span> -print0 <span class="m">2</span>&gt;/dev/null<span class="p">|</span>xargs <span class="nv">$xargs_opt</span> -0 -n1 basename
</span></code></pre></td></tr></table></div></figure>

<p>みたいに<code>-r</code>が使えるかどうかチェックしたりしてオプションをセットします。</p>

<div class="postscript">
  <p><strong>追記: 2017/06/13 </strong></p>

  <p><code>-v</code>(変数が定義済みチェック)はBash 4.1などちょっと前のBashだと使えない事があるので</p>

  <figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span></span><span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;</span><span class="nv">$xargs_opt</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">xargs_opt</span><span class="p">-A</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span> <span class="o">]</span><span class="p">;</span><span class="k">then</span>
</span><span class="line">  <span class="k">if</span> echo<span class="p">|</span>xargs -r &gt;/dev/null <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="p">;</span><span class="k">then</span>
</span><span class="line">    <span class="nv">xargs_opt</span><span class="o">=</span><span class="s2">&quot;-r&quot;</span>
</span><span class="line">  <span class="k">else</span>
</span><span class="line">    <span class="nv">xargs_opt</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
</span><span class="line">  <span class="k">fi</span>
</span><span class="line"><span class="k">fi</span>
</span><span class="line">find /path/to/dir/ -maxdepth <span class="m">1</span> -mindepth <span class="m">1</span> -type f -name <span class="s2">&quot;*wanted*&quot;</span> -print0 <span class="m">2</span>&gt;/dev/null<span class="p">|</span>xargs <span class="nv">$xargs_opt</span> -0 -n1 basename
</span></code></pre></td></tr></table></div></figure>

  <p>みたいな感じで<code>-v</code>を使わずに未定義化どうかチェックした方が良いです。</p>

  <p>上でやっているのは</p>

  <ul>
    <li>まず<code>-z</code>で未定義か空であることをチェック。</li>
    <li>そうであった場合、<code>xargs</code>が未定義かどうかをチェック。</li>
  </ul>

  <p><code>${var-X}</code>は<code>var</code>が未定義である場合に限り<code>X</code>を返します。
上の場合では<code>xargs_opt</code>が未定義であると<code>A</code>を返すので結果が正になります。</p>

  <p>後者だけのチェックだと、もし<code>xargs_opt</code>がもともと<code>A</code>という値だった場合にも
間違えて正になってしまうので
最初に未定義か空のチェックで<code>A</code>で無いことを確認し
その後で未定義かどうかのチェックをしています。</p>

  <p><code>${var:-X}</code>の様に<code>:</code>が入ると未定義もしくは空文字の場合に<code>X</code>が返る様になります。
(通常のシェルスクリプトではこちらの方がよく使います。)</p>

  <p><strong>追記ここまで</strong></p>
</div>

<h2 id="オプションを扱うラッパー関数">オプションを扱うラッパー関数</h2>

<p><code>xargs</code>を沢山使うような場合は</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span></span><span class="k">function</span> xargs_wrapper <span class="o">{</span>
</span><span class="line">  <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;</span><span class="nv">$xargs_opt</span><span class="s2">&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">xargs_opt</span><span class="p">-A</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span> <span class="o">]</span><span class="p">;</span><span class="k">then</span>
</span><span class="line">    <span class="k">if</span> echo<span class="p">|</span>xargs -r &gt;/dev/null <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span><span class="p">;</span><span class="k">then</span>
</span><span class="line">      <span class="nv">xargs_opt</span><span class="o">=</span><span class="s2">&quot;-r&quot;</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">      <span class="nv">xargs_opt</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
</span><span class="line">    <span class="k">fi</span>
</span><span class="line">  <span class="k">fi</span>
</span><span class="line">  xargs <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</span><span class="line"><span class="o">}</span>
</span><span class="line">find /path/to/dir/ -maxdepth <span class="m">1</span> -mindepth <span class="m">1</span> -type f -name <span class="s2">&quot;*wanted*&quot;</span> -print0 <span class="m">2</span>&gt;/dev/null<span class="p">|</span>xargs_wrapper -0 -n1 basename
</span></code></pre></td></tr></table></div></figure>

<div class="postscript">
  <p><strong>追記: 2017/06/13 </strong></p>

  <p>上に書いたように最初の分岐を<code>-z...</code>を使った方法に変更。</p>

  <p><strong>追記ここまで</strong></p>
</div>

<p>みたいなラッパー関数を作ってしまって回すと便利です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BSD(Mac)のsedでのタブ文字を変換する3つの方法]]></title>
    <link href="https://rcmdnk.com/blog/2016/09/13/computer-gnu-bsd-linux-mac/"/>
    <updated>2016-09-13T00:00:00+00:00</updated>
    <id>https://rcmdnk.com/blog/2016/09/13/computer-gnu-bsd-linux-mac</id>
    <content type="html"><![CDATA[<div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/B004D4Y302?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=B004D4Y302&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51Emp42I29L._SS200_.jpg" alt="sed &amp; awk (Nutshell Handbooks) 電子書籍: Arnold Robbins, Dale Dougherty" /></a>
</div>

<p><code>sed</code>でタブ文字をスペースとかに変更しようとした時、
Linuxで使っていたスクリプトがMacで使えなかったので
Macのsed(BSD sed)でのタブ文字の使い方についてちょっと調べてみました。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#bsd-sedでタブ文字を使う" id="markdown-toc-bsd-sedでタブ文字を使う">BSD sedでタブ文字を使う</a></li>
  <li><a href="#その他のタブ文字変換方法" id="markdown-toc-その他のタブ文字変換方法">その他のタブ文字変換方法</a></li>
  <li><a href="#まとめ" id="markdown-toc-まとめ">まとめ</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div>
  <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3802317723662375" data-ad-slot="5762198341"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  </div>
</div>

<h2 id="bsd-sedでタブ文字を使う">BSD sedでタブ文字を使う</h2>

<p>Linux版(GNU版)sedでは<code>\t</code>がタブ文字として使えて、これをそのまま</p>

<pre><code>$ printf "XXX\tXXX\n" | sed "s/\t/aaa/g"
XXXaaaXXX
</code></pre>

<p>の様にすればタブ部分が<code>XXX</code>に変わります。</p>

<p>これをMacやBSDなOSでやってみると</p>

<pre><code>$ printf "XXX\tXXX\n" | sed "s/\t/aaa/g"
XXX	XXX
</code></pre>

<p>こんな風にタブ部分がそのまま残ってしまいます。
ここにもGNU/BSDの違いが。</p>

<p>BSDな<code>sed</code>でタブ文字を変換する方法はいくつかありますが、
一つは
<i class="key">Ctrl</i>-<i class="key">V</i> <i class="key">Tab</i>と
<i class="key">Ctrl</i>-<i class="key">V</i>を使ったメタ文字直接入力を使って</p>

<pre><code>$ printf "XXX\tXXX\n" | sed "s/	/aaa/g"
</code></pre>

<p>と書く方法。上の<code>s/</code>の後の空白は単なるスペースではなく、
<i class="key">Ctrl</i>-<i class="key">V</i> <i class="key">Tab</i>で入力したものです。
(上のコマンドをそのままコピペするとスペースになってしまうので
試すと時は自分で<i class="key">Ctrl</i>-<i class="key">V</i>を入力する必要があります。)</p>

<p>次に<code>printf</code>を使ってタブ文字を出してあげる方法。</p>

<pre><code>$ printf "XXX\tXXX\n" | sed "s/$(printf "\t")/aaa/g"
</code></pre>

<p>例の最初のところで<code>\t</code>をタブ文字として出力してますが、
後ろの変換のところでもこれを使ってタブ文字を出して変換させています。</p>

<p>もう一つはANSI-Cクォーティングを使う方法。</p>

<pre><code>$ printf "XXX\tXXX\n" | sed s/$'\t'/"aaa"/g
</code></pre>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4904807049?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4904807049&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51q63OpBfKL._SS90_CR0,0,120,90_.jpg" alt="覚えて便利 いますぐ使える!シェルスクリプトシンプルレシピ54" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2014/01/13/computer-bash-zsh/">シェルスクリプトのreadでControl-a等を読み取る: ANSI C quoting</a></div></li></ul>

<p>単に<code>\t</code>等のメタ文字を使おうとするとそれぞれのコマンド自身で解析するため、
対応してないメタ文字は使えませんが、
<code>$'\t'</code>の様にANSI-C quotingを使うとシステムの方でまず<i class="key">Ctrl</i>-<i class="key">V</i>
と同様にタブ文字として認識してコマンドに渡すので
上手く行く、ということです。(多分。)</p>

<p><code>printf</code>は<code>\t</code>を理解しますが、<code>echo</code>は通常メタ文字を理解しません。
(<code>-e</code>オプションで理解する様になります。)
一方で<code>$'\t'</code>であれば通常の<code>echo</code>でもタブ文字として認識します。</p>

<p>BSD sedのmanを見ると<code>\n</code>(改行)は改行とマッチする、とありますが(<strong>Sed Regular Expressionsの所</strong>)
これだけ書いてあって他には無いのでメタ文字としてはこれだけが使えるみたいです。
また、<code>\n</code>も最初にマッチさせる方には使えますが
出力側として使うことは出来ません。
(GNUは出力としても使えます。)</p>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/B004D4Y302?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=B004D4Y302&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51Emp42I29L._SS90_CR0,0,120,90_.jpg" alt="sed &amp; awk (Nutshell Handbooks)" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2014/09/21/computer-bash/">sedで改行を出力する</a></div></li></ul>

<p>ちなみに、ANSI-C quotingをさらに<code>"</code>や<code>'</code>でクォートしてしまうと
ANSI-C quotingとは解釈されなくなるので<code>sed</code>のコマンド全体を囲うこことは避けないといけません。
この場合、スペースを含む文字を使いたい場合にエラーが出るので、
上の様に(<code>"aaa"</code>)必要な部分だけをクォートする必要があります。</p>

<p>これらの3つの方法はもちろんGNU <code>sed</code>でも使えます。</p>

<p>また、上の例はタブ文字を変換する、でしたが、
タブ文字へ変換する、も同様に上の3つの方法でタブ文字を出せば出来ます。</p>

<p>方法としては最初のものはここでも分かる通りパット見良くわからないのと
コピペ出来ないことがあるのでなるべく避けたほうが良いと思います。</p>

<p>最後のANSI-C quotingのものが一番短く書けるのでいいかな、と思いますが、
全体をクォートできないので場合によっては
<code>printf</code>を使った方がすっきりするかもしれません。</p>

<h2 id="その他のタブ文字変換方法">その他のタブ文字変換方法</h2>

<p><code>sed</code>は色々便利ですが、単にタブをスペースに返還したいだけ、とかであれば他の方法も。</p>

<p>まずは文字変換の<code>tr</code>:</p>

<pre><code>$ printf "XXX\tXXX\n" | tr "\t" " "
</code></pre>

<p><code>tr</code>にもGNUとBSDで微妙に違いがありますが、
<code>man</code>を見てみると、両方共に<code>\t</code>をタブとして理解する、という記述が見れ、
上の方法は両方でゆう宇高です。</p>

<p>この方法は一文字への変換なので複数スペースにしたかったり
複数文字へ変換したい場合は他の方法にする必要があります。</p>

<p>ターミナル出力と同じ様なスペース具合にしたい場合には
<code>expand</code>というコマンドを使う方法があります。</p>

<pre><code>$ printf "\tXXX\tXXX\n" | expand
        XXX     XXX$
</code></pre>

<p><code>expand</code>はタブ文字を展開するためのコマンドですが、
デフォルトでは
ターミナルに直接タブ文字を出した時と同じ表記になります。
大概の場合、上の様に行頭に来るタブは8文字、その後にあるタブは4文字で展開される様な形。
(タブ間の文字数や全体の文字数で感覚が狭くなったりもします。)</p>

<p>このコマンドもBSD版があって多少オプションが違ったりしますが
簡単な使い方は一緒です。
ターミナル表示と同じになるので、
タブ文字を使って出力しているログ等をどこかにコピペする時には
これを使ってタブを変換してから貼り付けると綺麗に表示することが出来ます。</p>

<p>他には<code>sed</code>以外の高等なコマンドを使う方法として、
<code>awk</code>を使う事も出来ます。</p>

<pre><code>$ printf "XXX\tXXX" | awk '{gsub("\t", "aaa");print}'
</code></pre>

<p><code>awk</code>はメタ文字をそのまま理解してくれる様です。
また、<code>awk</code>はGNUのものではないので
LinuxでもBSD(Mac)でもバージョンが同じであれば同じ機能です。
(<code>gawk</code>といったGNU拡張版もありますが。)</p>

<p>後はもうGNU版の<code>sed</code>を入れてしまう方法。
MacでHomebrewなら</p>

<pre><code>$ brew install gnu-sed
</code></pre>

<p>でGNU版のsedが<code>gsed</code>という名前で入ります。
もし、<code>sed</code>という名前でこれを代わりに使いたければ</p>

<pre><code>$ brew install gnu-sed --with-default-names
</code></pre>

<p>というオプションを付けると<code>gsed</code>ではなく<code>sed</code>という名前で
<strong>/usr/local/bin</strong>等にインストールされます。</p>

<h2 id="まとめ">まとめ</h2>

<p>シェルスクリプトを作る際に<code>sed</code>コマンドは複雑な処理をしようとする際には
便利なのでよく使いますが、
意外とGNU版、BSD版で違いが大きいので注意が必要だ、ということ。</p>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4756144152?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4756144152&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/61WVENM7J6L._SS90_CR0,0,120,90_.jpg" alt="デーモン君のソース探検―BSDのソースコードを探る冒険者たちのための手引き書 (BSD magazine Books)" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2013/06/27/computer-linux-mac-gnu-bsd/">Mac(BSD)でcpをGNU的に使う + おまけ</a></div></li></ul>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/B004D4Y302?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=B004D4Y302&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51Emp42I29L._SS90_CR0,0,120,90_.jpg" alt="sed &amp; awk (Nutshell Handbooks)" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2014/09/21/computer-bash/">sedで改行を出力する</a></div></li></ul>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4873113598?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4873113598&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51cRxtwo7IL._SS90_CR0,0,120,90_.jpg" alt="詳説 正規表現 第3版" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2015/07/19/computer-gnu-bsd/">GNU/BSDでのsedにおける正規表現の扱いの違い</a></div></li></ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macにおけるmktempコマンドがアップデートされていた？]]></title>
    <link href="https://rcmdnk.com/blog/2015/10/21/computer-mac-bsd-linux/"/>
    <updated>2015-10-21T00:00:00+00:00</updated>
    <id>https://rcmdnk.com/blog/2015/10/21/computer-mac-bsd-linux</id>
    <content type="html"><![CDATA[<div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4904807049?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4904807049&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51q63OpBfKL._SS200_.jpg" alt="覚えて便利 いますぐ使える!シェルスクリプトシンプルレシピ54" /></a>
</div>

<p>だいぶ前に
<a href="https://rcmdnk.com/blog/2013/12/08/computer-bash/">Bashでの一時ファイルの取り扱い</a>
という話を書きましたが、
ここでBSDの<code>mktemp</code>コマンドはGNUの物と違って面倒だ、的な事があったのですが、
その問題が消えてた件。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#以前あったmktempのgnubsdの違い" id="markdown-toc-以前あったmktempのgnubsdの違い">以前あったmktempのGNU/BSDの違い</a></li>
  <li><a href="#os-x-1011-el-capitan" id="markdown-toc-os-x-1011-el-capitan">OS X 10.11 El Capitan</a></li>
  <li><a href="#まとめ" id="markdown-toc-まとめ">まとめ</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div>
  <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3802317723662375" data-ad-slot="5762198341"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  </div>
</div>

<h2 id="以前あったmktempのgnubsdの違い">以前あったmktempのGNU/BSDの違い</h2>

<p><code>mktemp</code>コマンドは適当な一意的な名前を作成してくれ、
その名前をファイル名として一時的な出力に使ったりすることが出来ます。</p>

<p>デフォルトでは適当なランダムな名前を$TMPDIR以下に作成してくれるので、
スクリプトの中で、</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span></span><span class="ch">#!/bin/sh</span>
</span><span class="line"><span class="nv">logfile</span><span class="o">=</span><span class="k">$(</span>mktemp<span class="k">)</span> <span class="c1"># /tmp/tmp.XXXXXXXXXX</span>
</span><span class="line"><span class="nb">echo</span> <span class="nb">test</span> output &gt; <span class="nv">$logfile</span>
</span><span class="line">cat <span class="nv">$logfile</span>
</span><span class="line">rm -f <span class="nv">$logfile</span>
</span></code></pre></td></tr></table></div></figure>

<p>みたいな使い方が出来ます。
(<code>XXXXXXXXXX</code>の部分がランダムな文字列になります。)</p>

<p>複数の同じようなプロセスを走らせる場合にも
被らないので便利。</p>

<p>ですが、上の例はGNUの場合で、
BSDの<code>mktemp</code>だと引数なしで使うとエラーが出るので、</p>

<pre><code>$ mktemp -t tmp
</code></pre>

<p>の様にプレフィックス部分を指定して上げる必要がありました。</p>

<h2 id="os-x-1011-el-capitan">OS X 10.11 El Capitan</h2>

<p>これが、今、OS X 10.11 El Capitanにアップグレードした
手元のMacで見てみると、普通に</p>

<pre><code>$ mktemp
/var/folders/XX/XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/X/tmp.XXXXXXXX
</code></pre>

<p>と、引数無しで使えました。(MacのTMPDIRは上のような階層でディレクトリも常に変更されます。)</p>

<p>マニュアルを見てみると(<code>man mktemp</code>)、以下の様な文がありました。</p>

<pre><code>If no arguments are passed or if only the -d flag is passed mktemp behaves as if -t tmp was supplied.
</code></pre>

<p>まんま引数なしの場合には<code>-t tmp</code>と同じ様になるよ、と書いてあります。</p>

<p>一番下にある<code>HISTORY</code>を見てみると、<code>December 30, 2005</code>となっていますし、
今更アップデートされる様なところでもないと思ってたんですが、
ちょっと探してみると、WebにあるMac Developer Libraryのページに、</p>

<blockquote>
  <p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/mktemp.1.html">mktemp(1) Mac OS X Manual Page</a></p>
</blockquote>

<p>10.9 Mavericksの時のマニュアルがあって、
ここを見ると上の文章がありません。</p>

<p>実際、前に書いた時は2013年でMavericksの時の話なので
<strong>mktempは引数なしでは使えない</strong>と言うのは正しかったんだと思います。</p>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4774122610?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4774122610&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/518Z01TPCTL._SS90_CR0,0,120,90_.jpg" alt="シェルスクリプト基本リファレンス" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2013/12/08/computer-bash/">Bashでの一時ファイルの取り扱い</a></div></li></ul>

<p>もう手元にMavericksもYosemiteも無いので確かめられませんが。</p>

<p>それ以外の違いとしては</p>

<pre><code>On case-insensitive file systems, the effective number of unique names is significantly less; given six `Xs', mktemp will instead select 1 of 2176782336 (36 ** 6) possible unique file names.
</code></pre>

<p>という一文が入っていますが、
この直前に、</p>

<pre><code> The number of unique file names mktemp can return depends on the number of `Xs' provided; six `Xs' will result in mktemp selecting 1 of 56800235584 (62 ** 6) possible file names.
</code></pre>

<p>という文が入っています。</p>

<p>この文は以前もあったものなのですが、
ランダムな文字列の総数として、<code>アルファベット26文字 x 2 (大文字、小文字) + 数字(10) = 36</code>の組み合わせ
という計算になっていますが、
新しい文にあるように、ファイルシステムによっては大文字、小文字を区別しないものもあるので
この様なところでは<code>26 + 10 = 36</code>だけ、と言うことです。</p>

<p>実際、Macでは通常大文字小文字を区別しないのでこれに当たります。</p>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4838506961?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4838506961&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51Cv7ChquuL._SS90_CR0,0,120,90_.jpg" alt="ローマ字の書き方―大文字と小文字 単行本 – 1990/4" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2013/06/18/computer-windows-mac-linux/">ファイル名やディレクトリ名の大文字小文字</a></div></li></ul>

<p>この文についてはより正確に表現を変えただけで
中身が変わったわけではないと思います。</p>

<h2 id="まとめ">まとめ</h2>

<p>ということで、少なくともMac OS X 10.11 El Capitanでは
<code>mktemp</code>コマンドを使う際に
引数無しでGNUと同じ様に使うことが出来ます。</p>

<p>スクリプト等でMacとLinux両方で使える様な物を作る場合にも
今後はこの部分を気にせずに使える様になります。
(他のBSDを使わないとするならば。)</p>

<p>10.10 Yosemiteの時にどうだったかは分かりませんが、
いつの間にか変わっていた様です。</p>

<p>探して見る限り全くこの辺情報が見当たらないのですが…
(何故かDeveloper Libraryにはコマンドのマニュアルは10.9のものしか見当たらない。。。)</p>

<div class="postscript">
  <p><strong>追記: 2015/10/23</strong></p>

  <p>Yosemiteで試してみましたが、Yosemiteではまだ引数無しだと使えませんでした。</p>

  <p>なので、この変更はEl Capitanから入ったものの様です。</p>

  <p>他のコマンドでもアップデートがあるかもしれませんが、
全く情報が無い。。。</p>

  <p><strong>追記ここまで</strong></p>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[シェルスクリプトでの文字列、ファイルの行数の数え方: wc -lとgrep -c '']]></title>
    <link href="https://rcmdnk.com/blog/2015/09/04/computer-bash/"/>
    <updated>2015-09-04T00:00:00+00:00</updated>
    <id>https://rcmdnk.com/blog/2015/09/04/computer-bash</id>
    <content type="html"><![CDATA[<div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/B003U6E2SW?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=B003U6E2SW&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/81oOOaYG40L._SS200_.jpg" alt="NHK特集 行 ~比叡山 千日回峰~ [DVD]" /></a>
</div>

<p>シェルスクリプトで行数を数える、と言った場合に、
勝手に付けられたりする最後の行の改行コード等が
振る舞いを変える事があるのできちんと把握しておこう、と言う話。</p>

<p>以下は特に明記して無ければMacでBash 4.3.32での作業。
Zshは5.0.5です。
ですが、特に明記してないところでの作業については
Bash/Zsh、GNU/BSDの区別無く使える、としているものです。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#wc--l" id="markdown-toc-wc--l">wc -l</a></li>
  <li><a href="#grep--c-" id="markdown-toc-grep--c-">grep -c ‘’</a></li>
  <li><a href="#外部コマンドを使わずに数える" id="markdown-toc-外部コマンドを使わずに数える">外部コマンドを使わずに数える</a>    <ul>
      <li><a href="#while" id="markdown-toc-while">while</a></li>
      <li><a href="#配列化" id="markdown-toc-配列化">配列化</a>        <ul>
          <li><a href="#を使った普通の配列化" id="markdown-toc-を使った普通の配列化">()を使った普通の配列化</a></li>
          <li><a href="#bash-readarray" id="markdown-toc-bash-readarray">Bash: readarray</a></li>
          <li><a href="#zsh-f" id="markdown-toc-zsh-f">Zsh: $f</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#まとめ" id="markdown-toc-まとめ">まとめ</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div>
  <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3802317723662375" data-ad-slot="5762198341"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  </div>
</div>

<h2 id="wc--l">wc -l</h2>

<p>ファイル等の行数を数える、と言ったらまず思い浮かぶのが<code>wc</code>。
行数、単語数、文字数を数えてくれるコマンドで、<code>-l</code>で行だけを数えます。</p>

<pre><code>$ printf "$value" | wc -l
5
$ wc -l file.txt
10 file.txt
</code></pre>

<p>とか。</p>

<p>ちょっと注意が必要なのが、GNU wcだと上の様に左詰めで表示されますが、
Mac等のBSD系のwcだと</p>

<pre><code>$ wc -l file.txt
      10 file.txt
</code></pre>

<p>みたいに左に余計な空白が入ります。
数を取ってきて計算に入れたりする場合はそれ程問題になりませんが、</p>

<pre><code>$ n=$(printf "$value" | wc -l)
$ name="aaa_$n"
</code></pre>

<p>みたいな事をしようとすると、<code>name</code>に余計な空白が含まれてしまうので</p>

<pre><code>$ n=$(echo $(printf "$value" | wc -l))
</code></pre>

<p>とでもしておくとか空白を消す必要があります。
(<code>echo</code>とかにクォートしないで空白を持つ物を与えれば前後の空白は無視される。)</p>

<p>で、ここからが重要なところですが、
<a href="https://rcmdnk.com/blog/2015/08/27/gnu-bsd-linux-mac/">前回</a>
のとこでも書きましたが<code>wc</code>で数える行数は
<strong>newline</strong>の数、つまり改行の数になります。</p>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/1231777745?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=1231777745&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/41l3ki4DpnL._SS90_CR0,0,120,90_.jpg" alt="sed: sed-Politicus, Sozialistische Einheitspartei Deutschlands, Erich Honecker, Wolfgang Leonhard, Hans Mahle, Lutz Heilman" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2015/08/27/gnu-bsd-linux-mac/">sedを使ってファイルや複数行文字列の末尾の余計な空白行や改行を消す</a></div></li></ul>

<p>例えば文字だけで改行のないものは<strong>0行</strong>となります。</p>

<pre><code>$ printf "aaa"| wc -l
0
</code></pre>

<p>ファイルでも同じで、最終行に改行コードが入ってない場合、
最後の行を除いた行数になります<sup id="fninref:1"><a href="#fnin:1" rel="footnote">1</a></sup></p>

<p>ただし、ファイルに適当なエディタで</p>

<figure class="code"><figcaption><span>file.txt</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="text"><span class="line"><span></span>aaa
</span></code></pre></td></tr></table></div></figure>

<p>みたいな物を作って保存して試してみると</p>

<pre><code>$ wc -l file.txt
1 file.txt
</code></pre>

<p>と、一行表示される事が殆どだと思いますが、これも
<a href="https://rcmdnk.com/blog/2015/08/27/gnu-bsd-linux-mac/">前回</a>
書いたように、通常エディタでは最終行に自動的に改行コードを加えるからです。</p>

<pre><code>$ od -c file.txt
0000000    a   a   a  \n
0000004
</code></pre>

<p>と、<code>od</code>とかで調べてみれば最後に改行コードが入ってることが分かります。</p>

<h2 id="grep--c-">grep -c ‘’</h2>

<div class="postscript">
  <p><strong>追記: 2017/04/20 </strong></p>

  <p><code>grep -c ''</code>だとBSDのgrepで0行の場合に何も出力されないので
代わりに<code>grep -c ^</code>を使った方が良いです。</p>

  <ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/B0026OR2JU" rel="nofollow" target="_blank">&lt;img src='https://images-na.ssl-images-amazon.com/images/I/51yRZ4HWkGL._SS90_CR0,0,120,90_.jpg' alt='Amazon  grep Pocket Reference: A Quick Pocket Reference for a Utility Every Unix User Needs (Pocket Reference (O'Reilly)) [Kindle edition] by John Bambenek, Agnieszka Klus  Computer Science  Kindleストア'/&gt;</a>
</div>
</div><a class="click_box_link" href="https://rcmdnk.com/blog/2017/04/20/computer-linux-mac-bash-zsh/">grep -cで行数を数える時の罠</a></div></li></ul>

  <p><strong>追記ここまで</strong></p>
</div>

<p><code>grep</code>に<code>-c</code>オプションを与えると該当した行の数を数えてくれます。</p>

<p>これを使って検索する文字列に<code>''</code>(<code>""</code>)(空白も含まない単なるクォート(もしくはダブルクォート)の連続)を与えると、
<code>grep</code>では全ての行に該当する事になり、結果的に<code>-c</code>との組み合わせで
行数を数える事が出来ます。</p>

<p>ただし、こちらの場合は最後の行に改行コードがあろうがなかろうが
カウントします。</p>

<pre><code>$ printf "aaa"| grep -c ''
1
</code></pre>

<p>単に該当行を見ていくだけなので当然といえば当然。</p>

<p>これのほうが直感的な感じがしますが、注意が必要なのは逆に
改行だけを最後に与えた場合、</p>

<pre><code>$ printf "aaa\n"| grep -c ''
1
$ value="a
"
$ printf "$value"| grep -c ''
1
</code></pre>

<p>と、最後の改行の部分は無視されます。</p>

<p>改行が無視されるわけではなく、2つ以上あれば最後以外はカウントされます。</p>

<pre><code>$ printf "aaa\n\n\n"| grep -c ''
3
</code></pre>

<p><code>wc</code>と比べてみると</p>

<pre><code>$ printf "aaa"|wc -l
0
$ printf "aaa"|grep -c ''
1


$ printf "aaa\n"|wc -l
1
$ printf "aaa\n"|grep -c ''
1


$ printf "aaa\n\n"|wc -l
2
$ printf "aaa\n\n"|grep -c ''
2
</code></pre>

<p>と言った感じに、一番最初の<strong>最終行に改行がない</strong>状態の時だけ
別の結果を出します。</p>

<h2 id="外部コマンドを使わずに数える">外部コマンドを使わずに数える</h2>

<p><code>wc</code>も<code>grep</code>もほとんどの環境に入っていますし、
上ではGNU/BSDの違い等も気をつけていますが、
更にBash/Zshの機能だけで出来る様にしてみます。</p>

<h3 id="while">while</h3>

<p>まずは<code>while</code>を使って行でループを回して数える方法。</p>

<pre><code>$ value="aaa"
$ n=0
$ while read l;do ((n++));done &lt; &lt;(printf "$value")
$ echo $n
0
$ value="aaa\n"
$ n=0
$ while read l;do ((n++));done &lt; &lt;(printf "$value")
$ echo $n
1
</code></pre>

<p>という感じで<code>while</code>でループで行を回して単に<code>n</code>をインクリメントしてるだけです。</p>

<p>見て分かるように<code>while</code>は改行までを一文と読んで、
もし最後の行に改行がない場合にはその行は無視されます。</p>

<p>また、空白に関してはきちんとカウントされます。</p>

<pre><code>$ value="a\n\nb\nc"
$ while read l;do echo "$l";done &lt; &lt;(printf "$value")
a

b
$
</code></pre>

<p>なのでこの方法は<code>wc -l</code>と同じ結果になります。</p>

<p>また、ちょっと気をつけないといけないのが、値を渡す時に、
パイプで渡してしまうとパイプの後ろがサブプロセスになってしまうので
そこで<code>n</code>をインクリメントしても意味が無い、ということ。</p>

<pre><code>$ value="aaa\n"
$ n=0
$ printf "$value"|while read l;do ((n++));done
$ echo $n
0
</code></pre>

<p>な感じで<code>n</code>はパイプ行の後では元に戻っています。</p>

<p>一方、<code>while</code>に<code>done</code>の後からファイルの内容を<code>&lt;</code>で
与える形だと現在のプロセス上で実行されるので
<code>n</code>の変更が外でも保たれます。</p>

<p>変数に入ってる値を見たい場合には上の様に
<code>&lt;(command)</code>という形式の
<a href="https://en.wikipedia.org/wiki/Process_substitution">Process substitution</a>
を使って擬似ファイル化してそれを<code>while</code>に渡す事で上の様に
出来ます。</p>

<p>逆に、ファイルから入力する時に</p>

<pre><code>$ cat file.txt | while read l;do ...
</code></pre>

<p>としてしまうと
勿論サブプロセス化するので中での変更は外に出てきません。</p>

<p>また、BashやZshには
<a href="http://www.gnu.org/software/bash/manual/bashref.html#Here-Strings">Here String</a>
という機能があり、
<code>&lt;&lt;&lt;</code>を使って文字列をコマンドに後ろから標準入力として渡すことが出来ます。
これを使うと、</p>

<pre><code>$ value="a"
$ n=0
$ while read l;do echo "$l";((n++));done &lt;&lt;&lt; "$(printf "$value")"
a
$ echo $n
1
$ value="a\n\nb\nc\n\n\n"
$ n=0
$ while read l;do echo "$l";((n++));done &lt;&lt;&lt; "$(printf "$value")"
a

b
c
$ echo $n
4
</code></pre>

<p>と言った感じに出来ます。</p>

<p>この場合は最後以降の改行は全て無視されます。
ただし、改行が無くても最後の行はカウントされます。</p>

<p>また、<code>\n</code>とかを渡すにあたって直接<code>&lt;&lt;&lt;</code>に渡してしまうと</p>

<pre><code>$ while read l;do echo "$l";((n++));done &lt;&lt;&lt; "$value"
anbncnn
</code></pre>

<p>みたいになってしまうので、<code>printf</code>で改行表示した上で
それをクォートして渡す必要があります。</p>

<p>なので、こういった場合にはProcess substitution
を使ったほうがよっぽど完結。</p>

<p><code>\n</code>でなく直接改行が入ってる場合には</p>

<pre><code>$ value="a
b
c

"
$ while read l;do echo "$l";((n++));done &lt;&lt;&lt; "$a"
a
b
c

$
</code></pre>

<p>な感じで直接渡すことが出来、かつ直接書いた改行は
最後のところでもカウントされます。</p>

<h3 id="配列化">配列化</h3>

<h4 id="を使った普通の配列化">()を使った普通の配列化</h4>

<p>改行を区切りにして配列に入れて、配列内の値の個数を調べる事も出来ます。</p>

<p>ただし、この方法はちょっと気をつけないと途中の改行だけ(空白)の行を
無視してしまうこともあるので注意。</p>

<p>まず、
通常配列を作るにあたって<code>array=($value)</code>みたいにすると
空白や改行を区切りに配列を作りますが、
これを行ごとにしたければ
区切り文字設定の<code>IFS</code>というシェル変数を改行の<code>$'\n'</code>に変更します。</p>

<pre><code>$ # Normal Array
$ value="a b\nc\n\nd"
$ array=($(printf "$value"))
$ echo ${#array[@]}
4
$ for i in $(seq 0 3);do echo "array[$i]=${array[i]}";done
array[0]=a
array[1]=b
array[2]=c
array[3]=d
$ # Array divided by newline
$ orig_ifs=$IFS
$ IFS=$'\n'
$ array=($(printf "$value"))
$ echo ${#array[@]}
3
$ for i in $(seq 0 3);do echo "array[$i]=${array[i]}";done
array[0]=a b
array[1]=c
array[2]=d
array[3]=
$ IFS=$orig_ifs
</code></pre>

<p>こんな感じで<code>IFS=$'\n'</code>をした後には<code>()</code>内で展開されたものを
改行で区切って入れてくれます。</p>

<p><code>orig_ifs</code>に関して、<code>IFS</code>を変更してそのままにしておくと困るので
きちんと変更前の値を取っておいて戻す必要があります。</p>

<p>また、この場合は改行を<code>区切り</code>に使い、
さらに全体の前後や重複した改行は無視されるので、
まずは上の様に最後に改行が無くても最後の行も数えられます。</p>

<p>更に、最後に改行を入れても、この場合は幾つ入れても結果はおなじになります。</p>

<pre><code>$ array=($(printf "aaa")); echo ${#array[@]}
1
$ array=($(printf "aaa\n")); echo ${#array[@]}
1
$ array=($(printf "aaa\n\n")); echo ${#array[@]}
1
</code></pre>

<p>また、途中に複数の改行(空白行)がある場合は</p>

<pre><code>$ array=($(printf "a\n\nb")); echo ${#array[@]}
2
$ for i in $(seq 0 2);do echo "array[$i]=${array[i]}";done
array[0]=a
array[1]=b
array[2]=
</code></pre>

<p>な感じで途中の空白行は飛ばされます。
(区切り文字がいくつ続いても一つの区切りとして捉えられるため。)</p>

<p>ここでは<code>printf "%b" "a\n\nb"</code>みたいに<code>%b</code>フォーマットを使っても同じ結果になります。</p>

<p>なのでこれを<code>wc -l</code>とかと同じようには使えません。
<strong>空白以外の行数</strong>を数える事になります。</p>

<h4 id="bash-readarray">Bash: readarray</h4>

<p>一方、Bashには<code>readarray</code>というコマンドがあって、
これを使うと</p>

<pre><code>$ value="a\n\nb"
$ readarray array &lt; &lt;(printf "$value")
$ echo ${#array[@]}
3
$ for i in $(seq 0 2);do echo "array[$i]=${array[i]}";done
array[0]=a

array[1]=b
array[2]=
$ value="a\n\nb\n\n\n"
$ readarray array &lt; &lt;(printf "$value")
$ echo ${#array[@]}
5
$ for i in $(seq 0 2);do echo "array[$i]=${array[i]}";done
array[0]=a

array[1]=

array[2]=b

$
</code></pre>

<p>こんな感じで標準入力の値を入れることが出来ます。</p>

<p><code>readarray</code>は標準入力を行毎に分けて配列に詰めてくれるのですが、
ここでもパイプを使うと</p>

<pre><code>$ value="a\nb"
$ printf "$value"| readarray array
$ echo "${array[@]}"

$
</code></pre>

<p>という感じに、<code>readarray</code>の部分がパイプ後のサブプロセスに入ってしまうので
配列に詰めてもその変数が外では変更されません。</p>

<p>また、配列に詰める時に、改行で区切った上で、改行も
各要素に詰めます。</p>

<p>なので最初の<code>a</code>の後には空白行があります(<code>echo</code>で一つ改行が加えられるので)。</p>

<p><code>-t</code>オプションを使うと各行の最後の改行を消した状態で配列に詰めてくれるので、
配列に詰めた後に要素を使いたい場合は普通は</p>

<pre><code>$ readarray -t array &lt; &lt;(printf "$value")
</code></pre>

<p>の様にして使う事が多いと思います。(今回は数を数えるだけなので特に必要ない。)</p>

<p>最後の行に関しては改行があっても無くても1行には数えられます。</p>

<p>なので、</p>

<pre><code>$ readarray array &lt; &lt;(printf "aaa");echo ${#array[@]}
1
$ readarray array &lt; &lt;(printf "aaa\n");echo ${#array[@]}
1
$ readarray array &lt; &lt;(printf "aaa\n\n");echo ${#array[@]}
2
$
</code></pre>

<p>のように、こちらは<code>grep -c ""</code>と同じ結果になります。</p>

<h4 id="zsh-f">Zsh: $f</h4>

<p>ZshとBashで少し配列に関する仕様が違いますが、
まず、Zshはデフォルトでは要素は<code>[1]</code>から入っていきます。</p>

<pre><code>$ array=(a b c)
$ for i in $(seq 0 4);do echo "array[$i]=${array[i]}";done
array[0]=
array[1]=a
array[2]=b
array[3]=c
array[4]=
</code></pre>

<p>これに関しては</p>

<pre><code>setopt ksharrays
</code></pre>

<p>と<code>ksharrays</code>を設定する事で<code>[0]</code>から詰める様に変更することも出来ます。</p>

<p>また、変数を配列に入れようとすると、
Bashだと</p>

<pre><code>$ value="a b c"
$ array=($value)
$ for i in $(seq 0 3);do echo "array[$i]=${array[i]}";done
array[0]=a
array[1]=b
array[2]=c
array[3]=
$
</code></pre>

<p>こんな感じでクォートしないで渡すと変数内の区切りも認識しますが、
Zshだと、</p>

<pre><code>$ value="a b c"
$ array=($value)
$ for i in $(seq 0 3);do echo "array[$i]=${array[i]}";done
array[0]=
array[1]=a b c
array[2]=
array[3]=
$
</code></pre>

<p>な感じで、変数はひとかたまりとして認識されます。</p>

<p>ただ、<code>printf</code>等で展開する場合には中の区切りも見られるので、</p>

<pre><code>$ value="a b c"
$ array=($(printf "$value"))
$ for i in $(seq 0 3);do echo "array[$i]=${array[i]}";done
array[0]=
array[1]=a
array[2]=b
array[3]=c
$
</code></pre>

<p>と出来ます。</p>

<p>ですが、Zshでもやはり途中に空白行がある場合(改行コードが続く場合)は
無視されるのでBash同様普通に配列に詰めてると空白行以外をカウントすることになります。</p>

<p>一方、Zshでは<code>readarray</code>というコマンドはありませんが、
<code>$()</code>を使ってコマンド結果を使う時に、
さらに<code>${}</code>で囲って
前に<code>()</code>を付けて、</p>

<pre><code>${(X)$(command)}
</code></pre>

<p>とすることで<code>X</code>によって色々と展開方法を変更することが出来ます
<sup id="fninref:2"><a href="#fnin:2" rel="footnote">2</a></sup>。</p>

<p><code>X</code>の部分には複数の表現を入れることが出来て、
<code>f</code>を入れると以降の出力を<code>newline</code>で分ける、
<code>@</code>を入れると<code>"</code>で全体を囲った時に、出力の分けられた通りに出力する、
という形になります。</p>

<p><code>@</code>の説明が良くわからない感じですが、
BashやZshの配列をfor文で回そうとする時に使う<code>@</code>と一緒の意味です。</p>

<pre><code>$ array=(a b c)
$ for v in "${array[@]}";do echo "$v";done
a
b
c
$
</code></pre>

<p>となるように、<code>"</code>で囲った部分を一つの固まり、ではなく、
中で区切られてる場合にはその区切りごとに一つとして扱う、ということ。</p>

<p>つまりZshでは<code>"${array[@]}"</code>と<code>"${(@)array}"</code>は全く同じ意味になります。</p>

<pre><code>$ for v in "${(@)array}";do echo "$v";done
a
b
c
$
</code></pre>

<p>一方、<code>f</code>は区切りを<code>IFS</code>や配列内区切りも無視して新たに
改行を区切りとして出力します。</p>

<p>結果的に<code>$(command)</code>で出力されたものを改行で区切り要素に分け、
それを配列に分けた状態で要素を一つ一つ渡す、と言う形になります。</p>

<p>これを使うと途中の空白行とかもきちんと認識してくれます。</p>

<pre><code>$ value="a b\n\nc\nd\n\n\n"
$ array=("${(@f)$(printf "$value")}")
$ for i in $(seq 0 5);do echo "array[$i]=${array[i]}";done
array[0]=
array[1]=a b
array[2]=
array[3]=c
array[4]=d
array[5]=
$ echo ${#array[@]}
4
</code></pre>

<p>ただし、この様に末尾の改行は全て無視されます。
(上では、配列の数が4で、<code>a b</code>、<code>&lt;blank&gt;</code>、<code>c</code>、<code>d</code>の4行になってる)</p>

<p>なのでこの結果は<code>while</code>+<code>&lt;&lt;&lt;</code>と同じ結果になります。</p>

<h2 id="まとめ">まとめ</h2>

<div class="postscript">
  <p><strong>追記: 2017/04/20 </strong></p>

  <p><code>grep -c ''</code>だとBSDのgrepで0行の場合に何も出力されないので
代わりに<code>grep -c ^</code>を使った方が良いです。</p>

  <ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/B0026OR2JU" rel="nofollow" target="_blank">&lt;img src='https://images-na.ssl-images-amazon.com/images/I/51yRZ4HWkGL._SS90_CR0,0,120,90_.jpg' alt='Amazon  grep Pocket Reference: A Quick Pocket Reference for a Utility Every Unix User Needs (Pocket Reference (O'Reilly)) [Kindle edition] by John Bambenek, Agnieszka Klus  Computer Science  Kindleストア'/&gt;</a>
</div>
</div><a class="click_box_link" href="https://rcmdnk.com/blog/2017/04/20/computer-linux-mac-bash-zsh/">grep -cで行数を数える時の罠</a></div></li></ul>

  <p><strong>追記ここまで</strong></p>
</div>

<ul>
  <li><code>grep -c ''</code>
    <ul>
      <li>末尾の改行を考慮しない。</li>
      <li>Bashで<code>readarray</code>を使った方法も同じ様に出来る。</li>
    </ul>
  </li>
  <li><code>wc -l</code>
    <ul>
      <li>最終行に改行が無いと最終行が無視される。</li>
      <li><code>while</code>を使った方法で同じ事が出来る。</li>
    </ul>
  </li>
</ul>

<p>これまで行を数えるのに大体<code>wc -l</code>を使ってきましたが、
直感(少なくとも自分の)と合うのは<code>grep -c ''</code>なので
こっちに切り替えて行こうかな、と言う感じです。</p>

<p>勿論、意図的な部分もあったり、意図してなくても<code>wc -l</code>の方の仕様に
依っていたりすることもあるので単に書き換えるのは良くないですが。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sedを使ってファイルや複数行文字列の末尾の余計な空白行や改行を消す]]></title>
    <link href="https://rcmdnk.com/blog/2015/08/27/gnu-bsd-linux-mac/"/>
    <updated>2015-08-27T00:00:00+00:00</updated>
    <id>https://rcmdnk.com/blog/2015/08/27/gnu-bsd-linux-mac</id>
    <content type="html"><![CDATA[<div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/1231777745?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=1231777745&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/41l3ki4DpnL._SS200_.jpg" alt="sed: sed-Politicus, Sozialistische Einheitspartei Deutschlands, Erich Honecker, Wolfgang Leonhard, Hans Mahle, Lutz Heilman" /></a>
</div>

<p>文字列の最後に余計な空白行とかが付いてる時に消す事を
<code>sed</code>を使ってやろうと思ったら結構大変だった件。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#問題が起こった所" id="markdown-toc-問題が起こった所">問題が起こった所</a></li>
  <li><a href="#sedでの改行の消し方" id="markdown-toc-sedでの改行の消し方">sedでの改行の消し方</a></li>
  <li><a href="#sedで末尾の空白行を消す" id="markdown-toc-sedで末尾の空白行を消す">sedで末尾の空白行を消す</a></li>
  <li><a href="#sedで末尾の空白行を消す別の方法" id="markdown-toc-sedで末尾の空白行を消す別の方法">sedで末尾の空白行を消す別の方法</a></li>
  <li><a href="#sedで改行を出力する" id="markdown-toc-sedで改行を出力する">sedで改行を出力する</a></li>
  <li><a href="#ファイル末尾の改行について" id="markdown-toc-ファイル末尾の改行について">ファイル末尾の改行について</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div>
  <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-3802317723662375" data-ad-slot="5762198341"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  </div>
</div>

<h2 id="問題が起こった所">問題が起こった所</h2>

<p>シェルスクリプトの中で文字列を扱っている時に、
それを出力するにあたって末尾に空白行とかがある時にそれを無視
したい時がありました。</p>

<blockquote>
  <p><a href="https://github.com/rcmdnk/sentaku/issues/4">Issue #4 · rcmdnk/sentaku</a></p>
</blockquote>

<p>この辺でごちゃごちゃやってる時のこと。</p>

<p>シェルスクリプトの中で、文字列の行数を数えてその分だけ空きを作る事。
<code>tput</code>とかでカーソル位置を直接動かすので行数を自分で数えておく必要があります。</p>

<p>この際に、適当に作ってた時に文字列の最後に改行を入れることが前提になってて、
文字列によって実際の表示が崩れたりしたのでそれを直した話です。</p>

<p>所謂、<strong>エディタが勝手にテキストファイルの最後に入れた改行を削除したい</strong>、
という話とはちょっと別の話です。</p>

<h2 id="sedでの改行の消し方">sedでの改行の消し方</h2>

<p>sedコマンドは1行ずつ読み込んで操作を行うため、
改行の様な複数の行をまたぐ時には少し工夫が必要です。</p>

<p>改行を消すのによくやるのが</p>

<pre><code>$ printf "$value" | sed ':loop; N; $!b loop; s/\n//g'
</code></pre>

<p>こんな感じのコマンド
<sup id="fninref:1"><a href="#fnin:1" rel="footnote">1</a></sup>。</p>

<p><code>sed</code>は<code>;</code>で区切ることで複数のコマンドを一緒に書くことが出来るので、
上でやってることは</p>

<ul>
  <li><code>:loop</code>: <code>:</code> + <code>val</code>、でこの場所に<code>val</code>というラベルを設定(<code>loop</code>という文字列は何でも良い)。</li>
  <li><code>N</code>: 次の行を現在の行に繋げる。(この際、2つの行の間には改行コード(<code>\n</code>)が入る。)</li>
  <li><code>$!b loop</code>: <code>b loop</code>がラベル<code>loop</code>へ飛ぶ、と言う<code>goto</code>コマンド。
コマンドの前には条件を書くことが出来て、<code>$</code>は読み込んでる物の一番最後の行である、と言う条件、
さらに<code>!</code>は条件の否定、なので、ここでは、<strong>最終行でなければ<code>loop</code>に戻る</strong>、
という意味になります。結果的に最初の行から最後の行までを改行コードを挟んで繋げる事になります。</li>
  <li><code>s/\n//g</code>: よく使う置換コマンド。<code>\n</code>が改行で、置換後には何も無く、
さらに<code>g</code>を最後に指定してるので全ての改行コードを消すコマンド。</li>
</ul>

<p>と言った感じです。
<code>N</code>で行をつなげると、改行コードを含む一列として扱える様になるので、
すべての行をつなげた後、全体に対して置換をしています。</p>

<p>ただ、GNUのsedだとこれで大体上手く行くのですが、MacなんかのBSD sedだと上手くいきません。
BSDの場合には</p>

<pre><code>$ printf "$value\n\n" | sed -e :loop -e 'N; $!b loop' -e 's/\n//g'
</code></pre>

<p>の様に各コマンドを分けて書く必要があり<sup id="fninref:2"><a href="#fnin:2" rel="footnote">2</a></sup>、
さらに文字列が一行だけの時や、一行+改行コード、だけの場合
これを通すと消えてしまうので、それを避けるために少なくとも
2つ余計に改行コードを加えて置く必要があります<sup id="fninref:3"><a href="#fnin:3" rel="footnote">3</a></sup>。</p>

<p>分ける分にはGNU sedでも問題なく動くので、BSDでも動くようにするために
<code>-e</code>を使って分けて書いておいた方が互換性が良いです。</p>

<p>また、改行コードを加える点も両者で同じ振る舞いにするには必要です。</p>

<p>この最後の改行コードの部分がまた微妙に違う所があって、
BSD sedだと元のインプットの最後が改行コードであろうと何であろうと
必ず最後に改行コードを加えるのですが、
GNU sedだと元のインプットにあるかないかに依存します。</p>

<p>まとめてみると</p>

<ul>
  <li>BSD sed
    <ul>
      <li>
        <p>一行だけ(行の最後に改行だけある場合も含む)の場合は何も出力されなくなる。</p>

        <pre><code>$ value="a"
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'
$ # Nothing!
$ value="a
&gt; "
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'
$ # Nothing, too!
</code></pre>
      </li>
      <li>
        <p>最後に必ず改行コードが加えられる。</p>

        <pre><code>$ value="a
&gt; b"
$ printf "$value"| od -c
0000000    a  \n   b
0000003
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'|od -c
0000000    a   b  \n
0000003
$ value="a
&gt; b
&gt; "
$ printf "$value"|od -c
0000000    a  \n   b  \n
0000004
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'|od -c
0000000    a   b  \n
0000003
</code></pre>
      </li>
    </ul>
  </li>
  <li>GNU sed
    <ul>
      <li>
        <p>一行だけでも出力される。</p>

        <pre><code>$ value="a"
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'
a$
$ value="a
&gt; "
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'
a
$
</code></pre>
      </li>
      <li>
        <p>インプットに改行コードがあるかどうかで、最後に改行コードが付くかどうかが決まる。</p>

        <pre><code>$ value="a
&gt; b"
$ printf "$value"| od -c
0000000    a  \n   b
0000003
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'|od -c
0000000   a   b
0000002
$ value="a
&gt; b
&gt; "
$ printf "$value"|od -c
0000000    a  \n   b  \n
0000004
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'|od -c
0000000    a   b  \n
0000003
$ value="a
&gt; b
&gt;
&gt; "
$ printf "$value"|od -c
0000000   a  \n   b  \n  \n
0000005
$ printf "$value"|sed -e :loop -e 'N; $!b loop' -e 's/\n//g'|od -c
0000000   a   b  \n
0000003
</code></pre>
      </li>
    </ul>
  </li>
</ul>

<p>こんな感じです。</p>

<p>結構色々気をつけないといけないのと、
BSDの場合とGNUでインプットの最後に改行がある場合は
必ず最後に改行が1つ付きます。</p>

<p>なので単に改行を消したいだけなら<code>tr</code>とか
<sup id="fninref:4"><a href="#fnin:4" rel="footnote">4</a></sup>
を使ったほうが良いです。</p>

<pre><code>$ value="a
b
"
$ printf "$value"|tr -d '\n'|od -c
0000000    a   b
0000002
$
</code></pre>

<p>これだと最後の改行コードも含めて全ての改行コードを消せます。</p>

<h2 id="sedで末尾の空白行を消す">sedで末尾の空白行を消す</h2>

<p><code>sed</code>の改行コードを消す方法がわかったので、
これを使って末尾の空白行だけを消す事をやってみます。</p>

<p>最終的な形はこんな感じ。</p>

<pre><code>$ printf "%b\n\n" "$value"|sed -e :loop -e 'N; $!b loop' -e 's/[[:space:]\n]*$//'
</code></pre>

<p><code>sed</code>コマンドに関して、最後の置換えのコマンドを</p>

<pre><code>s/[[:space:]\n]*$//
</code></pre>

<p>としています。</p>

<p><code>[]</code>を使うとこの内のどれか、の<code>or</code>が作れ、<code>[:space:]</code>は空白文字、
<code>$</code>はここでは行末です。
<code>*</code>が直前文字の0個以上、なので末尾からみて、空白と改行コードが続く限り消されます。</p>

<p>また、上に書いた様に、BSDだと1行だけだと消えてしまったりするので
2つ改行コードを<code>value</code>に加えてから<code>sed</code>に渡しています。
(1つだけ渡すと、<code>value=a</code>のように一行かつ改行コードを含まないものに対しては
まだ出力が無くなる。)</p>

<p>改行コードを必ず渡すので、GNU sedの場合にも最後にかならず改行コードが
付くことになります。
これも行数を数える際に重要になってきます。</p>

<p><code>wc</code>を使って行数を測ってみようとすると、
<code>wc</code>のマニュアルにも</p>

<blockquote><p>NAME<br />       wc - print newline, word, and byte counts for each file</p></blockquote>

<p>とあるように
実際には改行の数を測る事になります。</p>

<p>なので、</p>

<pre><code>$ value="a"
$ printf "$a"|wc -l
0
</code></pre>

<p>と、なり、GNUの場合に最後に改行コードが無いと期待しているものより一行少なくなります。</p>

<p>なので最後の改行コードについて揃えておくことは重要。</p>

<p>これで、</p>

<pre><code>$ lines=$(printf "%b\n\n" "$value"|sed -e :loop -e 'N; $!b loop' -e 's/[[:space:]\n]*$//'|wc -l)
</code></pre>

<p>とでもしておけば末尾空白を除いた行数を得ることが出来ます。</p>

<h2 id="sedで末尾の空白行を消す別の方法">sedで末尾の空白行を消す別の方法</h2>

<p>最初、GNUの<code>sed</code>を使った時、<code>[:space:]</code>の代わりに空白をそのまま使って、</p>

<pre><code>$ printf "%b\n\n" "$value"|sed -e :loop -e 'N; $!b loop'  -e 's/[ \n]*$//'
</code></pre>

<p>としても上手く行きました。</p>

<p>ただ、これをBSDで試してみると上手く行きませんでした。</p>

<p>空白の代わりに<code>\s</code>と通常空白を表現する正規表現はGNUでもBSDでも効きません。
(GNUの<code>-r</code>とかBSDの<code>-E</code>など拡張正規表現を使うようなオプションを使ってもダメでした。)</p>

<p>そこで、<code>[:space:]</code>をする代わりに、最初はこんな感じのを作っていました。</p>

<pre><code>$ printf "%b\n\n" "$value"|sed -e :loop -e 'N; s/ *$//; $!b loop'  -e 's/\n*$//'
</code></pre>

<p>まず、最後から見ていくと、
<code>'s/\n*$//'</code>で、行末の改行コードを全て消しています。</p>

<p>次に、<code>sed</code>で<code>N</code>を使って行を繋げて行きますが、この際、
<code>s/ *$//</code>を挟んで行末の空白を消しています。
これは、最後に<code>\n*$</code>を使って消そうとするとき、
途中に空白文字があるとこれから外れてしまうのを避けるためです。</p>

<p>これだと行の末尾にある空白が全て削除されてしまいますが、
末尾の空白文字だけある所が全部消えて改行だけになるので、
最後の改行だけの削除で消えてくれます。</p>

<p>行末空白を消しても構わない、むしろ要らない、
といった場合にはこんな方法もありかと。</p>

<h2 id="sedで改行を出力する">sedで改行を出力する</h2>

<p>今回は<code>sed</code>でインプット側の改行コードを操作する話でしたが、
逆に改行コードを出力しようとするときにも
GNU/BSDで違いがあったりして結構面倒なので注意です。</p>

<ul class="post_card"><li class="index_click_box"><div class="group"><div class="title-small-thumbnail"><div class="amazon-img">
  <a href="//www.amazon.co.jp/gp/product/4873113598?ie=UTF8&amp;camp=1207&amp;creative=8411&amp;creativeASIN=4873113598&amp;linkCode=shr&amp;tag=rcmdnk0c-22" rel="nofollow" target="_blank"><img src="https://images-na.ssl-images-amazon.com/images/I/51cRxtwo7IL._SS90_CR0,0,120,90_.jpg" alt="詳説 正規表現 第3版" /></a>
</div></div><a class="click_box_link" href="https://rcmdnk.com/blog/2015/07/19/computer-gnu-bsd/">GNU/BSDでのsedにおける正規表現の扱いの違い</a></div></li></ul>

<h2 id="ファイル末尾の改行について">ファイル末尾の改行について</h2>

<p>今回の話とは別の話になりますが、
ファイル末尾の改行についてもついでに色々見たのでまとめておきます。</p>

<p>テキストファイルを作って普通に保存すると、
大概のエディタなどでは末尾に自動的に改行コードを加えます。</p>

<p>これは、改行コードを行の区切り(<em>separator</em>)と考えるか、
行の終わり(<em>terminator</em>)と考えるか、で末尾に必ず付け加える必要性が
変わってきますが、
POSIX的な考え方では<strong>terminator</strong>として考えるので
<sup id="fninref:5"><a href="#fnin:5" rel="footnote">5</a></sup>、
これと同じ考え方のエディタでは保存時に最終行には最後に改行コードを加える様になっています。</p>

<p>上の<code>wc</code>のケースでも行数は改行コードの数を数える事になるので、
最後の行に改行コードが無いと直感的に違った物が出てきてしまいます。</p>

<p><code>gcc</code>等でも改行が無いファイルを使おうとすると警告が出たりもします
<sup id="fninref:6"><a href="#fnin:6" rel="footnote">6</a></sup>。</p>

<p>この辺り、場合によってはきちんとチェックする必要も出てきます
<sup id="fninref:7"><a href="#fnin:7" rel="footnote">7</a></sup>。</p>

<p>Vimでも通常ファイルを開いて保存する際、
最後に改行コードが無ければ自動的に改行コードが付け加えられます。</p>

<p>これを避けるためには、以前は</p>

<pre><code>: set binary noeol
</code></pre>

<p>と、バイナリの設定を行って、さらにeol(endofline)を無効にする方法が
良く出てくるものでした。</p>

<p><code>eol</code>はまさに最後に改行を加えるかどうか、と言うオプションですが、
<code>noeol</code>としてもバイナリ出ない限りは必ず改行を加える様になっています。</p>

<p>なので、<code>set binary</code>をした上で<code>set noeol</code>とする必要があります。</p>

<p>ただし、この<code>set binary</code>によって通常のテキストモードでは
良しなにVimがしてくれてたエンコード等を上手く扱えなくなるので
色々と不具合が出ることがあります。</p>

<p>と、そこで最近新しく<code>fixeol</code>というオプション
7.4の<a href="https://groups.google.com/forum/#!topic/vim_dev/sMqIDokn9gY/discussion">Patch 7.4.785</a>
から入り、この問題を解決できる様になりました
<sup id="fninref:8"><a href="#fnin:8" rel="footnote">8</a></sup>。</p>

<p>Vimのマニュアルの<code>eol</code>の部分には、7.4.785以降が入っていれば</p>

<pre><code>                        'endofline' 'eol' 'noendofline' 'noeol'
'endofline' 'eol'       boolean (default on)
                        local to buffer
                        {not in Vi}
        When writing a file and this option is off and the 'binary' option
        is on, or 'fixeol' option is off, no &lt;EOL&gt; will be written for the
        last line in the file.  This option is automatically set or reset when
        starting to edit a new file, depending on whether file has an &lt;EOL&gt;
        for the last line in the file.  Normally you don't have to set or
        reset this option.
        When 'binary' is off and 'fixeol' is on the value is not used when
        writing the file.  When 'binary' is on or 'fixeol' is off it is used
        to remember the presence of a &lt;EOL&gt; for the last line in the file, so
        that when you write the file the situation from the original file can
        be kept.  But you can change it if you want to.
</code></pre>

<p>の様に書いてあります。</p>

<p><code>fixeol</code>はデフォルトでは有効ですが、<code>set nofixeol</code>をしておけば、
通常のテキストモードでも改行コードを勝手に付け加えることはなくなります。</p>

<p>これを常に無効にしたい場合、<strong>.vimrc</strong>に以下の様に設定しておきます。</p>

<figure class="code"><figcaption><span>.vimrc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="vim"><span class="line"><span></span><span class="k">if</span> <span class="p">(</span><span class="k">v</span>:version <span class="p">==</span> <span class="m">704</span> &amp;&amp; has<span class="p">(</span><span class="s2">&quot;patch785&quot;</span><span class="p">))</span> <span class="p">||</span> <span class="k">v</span>:version <span class="p">&gt;=</span> <span class="m">705</span>
</span><span class="line">  <span class="k">set</span> nofixeol
</span><span class="line"><span class="k">endif</span>
</span></code></pre></td></tr></table></div></figure>

<p>新しいオプションなので、古い環境との互換性を保たせるためにバージョンを見て
十分ならばこのオプションを設定するようにしています。</p>

]]></content>
  </entry>
  
</feed>
